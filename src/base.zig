//! generated by zig-lsp-codegen

const std = @import("std");

pub const URI = []const u8;
/// The URI of a document
pub const DocumentUri = []const u8;
/// A JavaScript regular expression; never used
pub const RegExp = []const u8;

pub const LSPAny = std.json.Value;
pub const LSPArray = []LSPAny;
pub const LSPObject = std.json.ArrayHashMap(std.json.Value);

/// See https://www.jsonrpc.org/specification
pub const JsonRPCMessage = union(enum) {
    request: Request,
    notification: Notification,
    response: Response,

    pub const ID = union(enum) {
        number: i64,
        string: []const u8,

        pub fn eql(a: ID, b: ID) bool {
            if (std.meta.activeTag(a) != std.meta.activeTag(b)) return false;
            switch (a) {
                .number => return a.number == b.number,
                .string => return std.mem.eql(u8, a.string, b.string),
            }
        }

        test eql {
            const id_number_3: ID = .{ .number = 3 };
            const id_number_7: ID = .{ .number = 7 };
            const id_string_foo: ID = .{ .string = "foo" };
            const id_string_bar: ID = .{ .string = "bar" };
            const id_string_3: ID = .{ .string = "3" };

            try std.testing.expect(id_number_3.eql(id_number_3));
            try std.testing.expect(!id_number_3.eql(id_number_7));

            try std.testing.expect(id_string_foo.eql(id_string_foo));
            try std.testing.expect(!id_string_foo.eql(id_string_bar));

            try std.testing.expect(!id_number_3.eql(id_string_foo));
            try std.testing.expect(!id_number_3.eql(id_string_3));
        }

        pub fn jsonParse(allocator: std.mem.Allocator, source: anytype, options: std.json.ParseOptions) std.json.ParseError(@TypeOf(source.*))!ID {
            switch (try source.peekNextTokenType()) {
                .number => return .{ .number = try std.json.innerParse(i64, allocator, source, options) },
                .string => return .{ .string = try std.json.innerParse([]const u8, allocator, source, options) },
                else => return error.SyntaxError,
            }
        }

        pub fn jsonParseFromValue(allocator: std.mem.Allocator, source: std.json.Value, options: std.json.ParseOptions) std.json.ParseFromValueError!ID {
            _ = allocator;
            _ = options;
            switch (source) {
                .integer => |number| return .{ .number = number },
                .string => |string| return .{ .string = string },
                else => return error.UnexpectedToken,
            }
        }

        pub fn jsonStringify(self: ID, stream: anytype) @TypeOf(stream.*).Error!void {
            switch (self) {
                inline else => |value| try stream.write(value),
            }
        }
    };

    pub const Request = struct {
        comptime jsonrpc: []const u8 = "2.0",
        /// The request id.
        id: ID,
        /// The method to be invoked.
        method: []const u8,
        /// The requests's params. The `std.json.Value` can only be `.null`, `.array` or `.object`.
        ///
        /// `params == null` means that the was no `"params"` field. `params == .null` means that the `"params"` field was set to `null`.
        params: ?std.json.Value,
    };

    pub const Notification = struct {
        comptime jsonrpc: []const u8 = "2.0",
        /// The method to be invoked.
        method: []const u8,
        /// The notification's params. The `std.json.Value` can only be `.null`, `.array` or `.object`.
        ///
        /// `params == null` means that the was no `"params"` field. `params == .null` means that the `"params"` field was set to `null`.
        params: ?std.json.Value,
    };

    pub const Response = struct {
        comptime jsonrpc: []const u8 = "2.0",
        /// The request id.
        ///
        /// It must be the same as the value of the `id` member in the `Request` object.
        /// If there was an error in detecting the id in the `Request` object (e.g. `Error.Code.parse_error`/`Error.Code.invalid_request`), it must be `null`.
        id: ?ID,
        /// The result of a request. This member is REQUIRED on success.
        /// This member MUST NOT exist if there was an error invoking the m
        result: ?std.json.Value,
        /// The error object in case a request fails.
        @"error": ?Error,

        pub const Error = struct {
            /// A number indicating the error type that occurred.
            code: Code,
            /// A string providing a short description of the error.
            message: []const u8,
            /// A primitive or structured value that contains additional
            /// information about the error. Can be omitted.
            data: std.json.Value = .null,

            /// The error codes from and including -32768 to -32000 are reserved for pre-defined errors. Any code within this range, but not defined explicitly below is reserved for future use.
            ///
            /// The remainder of the space is available for application defined errors.
            pub const Code = enum(i64) {
                /// Invalid JSON was received by the server. An error occurred on the server while parsing the JSON text.
                parse_error = -32700,
                /// The JSON sent is not a valid Request object.
                invalid_request = -32600,
                /// The method does not exist / is not available.
                method_not_found = -32601,
                /// Invalid method parameter(s).
                invalid_params = -32602,
                /// Internal JSON-RPC error.
                internal_error = -32603,

                /// -32000 to -32099 are reserved for implementation-defined server-errors.
                _,

                pub fn jsonStringify(code: Code, stream: anytype) @TypeOf(stream.*).Error!void {
                    try stream.write(@intFromEnum(code));
                }
            };
        };

        pub fn jsonStringify(response: Response, stream: anytype) @TypeOf(stream.*).Error!void {
            try stream.beginObject();

            try stream.objectField("jsonrpc");
            try stream.write("2.0");

            if (response.id) |id| {
                try stream.objectField("id");
                try stream.write(id);
            } else if (stream.options.emit_null_optional_fields) {
                try stream.objectField("id");
                try stream.write(null);
            }

            try stream.objectField(if (response.result != null) "result" else "error");
            if (response.result) |result_val| {
                try stream.write(result_val);
            } else if (response.@"error") |error_val| {
                try stream.write(error_val);
            } else unreachable;

            try stream.endObject();
        }
    };

    pub fn jsonParse(
        allocator: std.mem.Allocator,
        source: anytype,
        options: std.json.ParseOptions,
    ) std.json.ParseError(@TypeOf(source.*))!JsonRPCMessage {
        if (try source.next() != .object_begin) return error.UnexpectedToken;

        var fields: Fields = .{};

        while (true) {
            const field_name = blk: {
                const name_token = try source.nextAllocMax(allocator, .alloc_if_needed, options.max_value_len.?);
                const maybe_field_name = switch (name_token) {
                    inline .string, .allocated_string => |slice| std.meta.stringToEnum(std.meta.FieldEnum(Fields), slice),
                    .object_end => break, // No more fields.
                    else => return error.UnexpectedToken,
                };

                switch (name_token) {
                    .string => {},
                    .allocated_string => |slice| allocator.free(slice),
                    else => unreachable,
                }

                break :blk maybe_field_name orelse {
                    if (options.ignore_unknown_fields) {
                        try source.skipValue();
                        continue;
                    } else {
                        return error.UnexpectedToken;
                    }
                };
            };

            // check for contradicting fields
            switch (field_name) {
                .jsonrpc => {},
                .id => {},
                .method, .params => {
                    const is_result_set = if (fields.result) |result| result != .null else false;
                    if (is_result_set or fields.@"error" != null) {
                        return error.UnexpectedToken;
                    }
                },
                .result => {
                    if (fields.@"error" != null) {
                        return error.UnexpectedToken;
                    }
                },
                .@"error" => {
                    const is_result_set = if (fields.result) |result| result != .null else false;
                    if (is_result_set) {
                        return error.UnexpectedToken;
                    }
                },
            }

            switch (field_name) {
                inline else => |comptime_field_name| {
                    if (comptime_field_name == field_name) {
                        if (@field(fields, @tagName(comptime_field_name))) |_| {
                            switch (options.duplicate_field_behavior) {
                                .use_first => {
                                    _ = try Fields.parse(comptime_field_name, allocator, source, options);
                                    break;
                                },
                                .@"error" => return error.DuplicateField,
                                .use_last => {},
                            }
                        }
                        @field(fields, @tagName(comptime_field_name)) = try Fields.parse(comptime_field_name, allocator, source, options);
                    }
                },
            }
        }

        return try fields.toMessage();
    }

    pub fn jsonParseFromValue(
        allocator: std.mem.Allocator,
        source: std.json.Value,
        options: std.json.ParseOptions,
    ) std.json.ParseFromValueError!JsonRPCMessage {
        if (source != .object) return error.UnexpectedToken;

        var fields: Fields = .{};

        for (source.object.keys(), source.object.values()) |field_name, field_source| {
            inline for (std.meta.fields(Fields)) |field| {
                const field_enum = comptime std.meta.stringToEnum(std.meta.FieldEnum(Fields), field.name).?;
                if (std.mem.eql(u8, field.name, field_name)) {
                    @field(fields, field.name) = try Fields.parseFromValue(field_enum, allocator, field_source, options);
                    break;
                }
            } else {
                // Didn't match anything.
                if (!options.ignore_unknown_fields) return error.UnknownField;
            }
        }

        return try fields.toMessage();
    }

    pub fn jsonStringify(message: JsonRPCMessage, stream: anytype) @TypeOf(stream.*).Error!void {
        switch (message) {
            inline else => |item| try stream.write(item),
        }
    }

    /// Method names that begin with the word rpc followed by a period character (U+002E or ASCII 46) are reserved for rpc-internal methods and extensions and MUST NOT be used for anything else.
    pub fn is_reserved_method_name(name: []const u8) bool {
        return std.mem.startsWith(u8, name, "rpc.");
    }

    const Fields = struct {
        jsonrpc: ?[]const u8 = null,
        method: ?[]const u8 = null,
        id: ?ID = null,
        params: ?std.json.Value = null,
        result: ?std.json.Value = null,
        @"error": ?Response.Error = null,

        fn parse(
            comptime field: std.meta.FieldEnum(@This()),
            allocator: std.mem.Allocator,
            source: anytype,
            options: std.json.ParseOptions,
        ) std.json.ParseError(@TypeOf(source.*))!std.meta.FieldType(@This(), field) {
            return switch (field) {
                .jsonrpc, .method => try std.json.innerParse([]const u8, allocator, source, options),
                .id => try std.json.innerParse(?JsonRPCMessage.ID, allocator, source, options),
                .params => switch (try source.peekNextTokenType()) {
                    .null => {
                        std.debug.assert(try source.next() == .null);
                        return .null;
                    },
                    .object_begin, .array_begin => try std.json.Value.jsonParse(allocator, source, options),
                    else => error.UnexpectedToken, // "params" field must be null/object/array
                },
                .result => try std.json.Value.jsonParse(allocator, source, options),
                .@"error" => try std.json.innerParse(Response.Error, allocator, source, options),
            };
        }

        fn parseFromValue(
            comptime field: std.meta.FieldEnum(@This()),
            allocator: std.mem.Allocator,
            source: std.json.Value,
            options: std.json.ParseOptions,
        ) std.json.ParseFromValueError!std.meta.FieldType(@This(), field) {
            return switch (field) {
                .jsonrpc, .method => try std.json.innerParseFromValue([]const u8, allocator, source, options),
                .id => try std.json.innerParseFromValue(?JsonRPCMessage.ID, allocator, source, options),
                .params => switch (source) {
                    .null, .object, .array => source,
                    else => error.UnexpectedToken, // "params" field must be null/object/array
                },
                .result => source,
                .@"error" => try std.json.innerParseFromValue(Response.Error, allocator, source, options),
            };
        }

        fn toMessage(self: Fields) !JsonRPCMessage {
            const jsonrpc = self.jsonrpc orelse
                return error.MissingField;
            if (!std.mem.eql(u8, jsonrpc, "2.0"))
                return error.UnexpectedToken; // the "jsonrpc" field must be "2.0"

            if (self.method) |method_val| {
                if (self.result != null or self.@"error" != null) {
                    return error.UnexpectedToken; // the "method" field indicates a request or notification which can't have the "result" or "error" field
                }
                if (self.params) |params_val| {
                    switch (params_val) {
                        .null, .object, .array => {},
                        else => unreachable,
                    }
                }

                if (self.id) |id_val| {
                    return .{
                        .request = .{
                            .method = method_val,
                            .params = self.params,
                            .id = id_val,
                        },
                    };
                } else {
                    return .{
                        .notification = .{
                            .method = method_val,
                            .params = self.params,
                        },
                    };
                }
            } else {
                if (self.@"error" != null) {
                    const is_result_set = if (self.result) |result| result != .null else false;
                    if (is_result_set) return error.UnexpectedToken; // the "result" and "error" fields can't both be set
                } else {
                    const is_result_set = self.result != null;
                    if (!is_result_set) return error.MissingField;
                }

                return .{
                    .response = .{
                        .result = self.result,
                        .@"error" = self.@"error",
                        .id = self.id,
                    },
                };
            }
        }
    };

    test Request {
        try testParse(
            \\{"jsonrpc": "2.0", "id": 1, "method": "Die", "params": null}
        , .{
            .request = .{
                .id = .{ .number = 1 },
                .method = "Die",
                .params = .null,
            },
        }, .{});
        try testParse(
            \\{"id": "Würde", "method": "des", "params": null, "jsonrpc": "2.0"}
        , .{
            .request = .{
                .id = .{ .string = "Würde" },
                .method = "des",
                .params = .null,
            },
        }, .{});
        try testParse(
            \\{"method": "ist", "params": {}, "jsonrpc": "2.0", "id": "Menschen"}
        , .{
            .request = .{
                .id = .{ .string = "Menschen" },
                .method = "ist",
                .params = .{ .object = undefined },
            },
        }, .{});
        try testParse(
            \\{"method": ".", "jsonrpc": "2.0", "id": "unantastbar"}
        , .{
            .request = .{
                .id = .{ .string = "unantastbar" },
                .method = ".",
                .params = null,
            },
        }, .{});
    }

    test Notification {
        try testParse(
            \\{"jsonrpc": "2.0", "method": "foo", "params": null}
        , .{
            .notification = .{
                .method = "foo",
                .params = .null,
            },
        }, .{});
        try testParse(
            \\{"method": "bar", "params": null, "jsonrpc": "2.0"}
        , .{
            .notification = .{
                .method = "bar",
                .params = .null,
            },
        }, .{});
        try testParse(
            \\{"params": [], "method": "baz", "jsonrpc": "2.0"}
        , .{
            .notification = .{
                .method = "baz",
                .params = .{ .array = undefined },
            },
        }, .{});
        try testParse(
            \\{"method": "booze?", "jsonrpc": "2.0"}
        , .{
            .notification = .{
                .method = "booze?",
                .params = null,
            },
        }, .{});
    }

    test "Notification allow setting the 'id' field to null" {
        try testParse(
            \\{"jsonrpc": "2.0", "id": null, "method": "foo", "params": null}
        , .{
            .notification = .{
                .method = "foo",
                .params = .null,
            },
        }, .{});
    }

    test Response {
        try testParse(
            \\{"jsonrpc": "2.0", "id": 1, "result": null}
        , .{ .response = .{
            .id = .{ .number = 1 },
            .result = .null,
            .@"error" = null,
        } }, .{});

        try testParseExpectedError(
            \\{"jsonrpc": "2.0", "id": 1}
        ,
            error.MissingField,
            error.MissingField,
            .{},
        );

        try testParse(
            \\{"id": "id", "jsonrpc": "2.0", "result": null, "error": {"code": 3, "message": "foo", "data": null}}
        , .{ .response = .{
            .id = .{ .string = "id" },
            .result = .null,
            .@"error" = .{ .code = @enumFromInt(3), .message = "foo", .data = .null },
        } }, .{});
        try testParse(
            \\{"id": "id", "jsonrpc": "2.0", "error": {"code": 42, "message": "bar"}}
        , .{ .response = .{
            .id = .{ .string = "id" },
            .result = null,
            .@"error" = .{ .code = @enumFromInt(42), .message = "bar", .data = .null },
        } }, .{});
    }

    test "validate that the 'params' is null/array/object" {
        // null
        try testParse(
            \\{"jsonrpc": "2.0", "id": 1, "method": "foo", "params": null}
        , .{ .request = .{
            .id = .{ .number = 1 },
            .method = "foo",
            .params = .null,
        } }, .{});
        try testParse(
            \\{"jsonrpc": "2.0", "id": 1, "method": "foo"}
        , .{ .request = .{
            .id = .{ .number = 1 },
            .method = "foo",
            .params = null,
        } }, .{});

        // bool
        try testParseExpectedError(
            \\{"jsonrpc": "2.0", "id": 1, "method": "foo", "params": true}
        ,
            error.UnexpectedToken,
            error.UnexpectedToken,
            .{},
        );

        // integer
        try testParseExpectedError(
            \\{"jsonrpc": "2.0", "id": 1, "method": "foo", "params": 5}
        ,
            error.UnexpectedToken,
            error.UnexpectedToken,
            .{},
        );

        // float
        try testParseExpectedError(
            \\{"jsonrpc": "2.0", "id": 1, "method": "foo", "params": 4.2}
        ,
            error.UnexpectedToken,
            error.UnexpectedToken,
            .{},
        );

        // string
        try testParseExpectedError(
            \\{"jsonrpc": "2.0", "id": 1, "method": "foo", "params": "bar"}
        ,
            error.UnexpectedToken,
            error.UnexpectedToken,
            .{},
        );

        // array
        try testParse(
            \\{"jsonrpc": "2.0", "id": 1, "method": "foo", "params": []}
        , .{ .request = .{
            .id = .{ .number = 1 },
            .method = "foo",
            .params = .{ .array = undefined },
        } }, .{});

        // object
        try testParse(
            \\{"jsonrpc": "2.0", "id": 1, "method": "foo", "params": {}}
        , .{ .request = .{
            .id = .{ .number = 1 },
            .method = "foo",
            .params = .{ .object = undefined },
        } }, .{});
    }

    test "ignore_unknown_fields" {
        try testParse(
            \\{"jsonrpc": "2.0", "id": 1, "other": null, "method": "foo", "params": null, "extra": "."}
        , .{
            .request = .{
                .id = .{ .number = 1 },
                .method = "foo",
                .params = .null,
            },
        }, .{ .ignore_unknown_fields = true });
        try testParse(
            \\{"other": "", "jsonrpc": "2.0", "extra": {}, "method": "bar"}
        , .{
            .notification = .{
                .method = "bar",
                .params = null,
            },
        }, .{ .ignore_unknown_fields = true });
        try testParseExpectedError(
            \\{"jsonrpc": "2.0", "id": 1, "other": null, ".": "Sie", "params": {}, "extra": {}}
        ,
            error.UnexpectedToken,
            error.UnknownField,
            .{ .ignore_unknown_fields = false },
        );
    }

    fn testParse(message: []const u8, expected: JsonRPCMessage, parse_options: std.json.ParseOptions) !void {
        const allocator = std.testing.allocator;

        const parsed_from_slice = try std.json.parseFromSlice(JsonRPCMessage, allocator, message, parse_options);
        defer parsed_from_slice.deinit();

        const parsed_value = try std.json.parseFromSlice(std.json.Value, allocator, message, parse_options);
        defer parsed_value.deinit();

        const parsed_from_value = try std.json.parseFromValue(JsonRPCMessage, allocator, parsed_value.value, parse_options);
        defer parsed_from_value.deinit();

        const from_slice_stringified = try std.json.stringifyAlloc(allocator, parsed_from_slice.value, .{ .whitespace = .indent_2 });
        defer allocator.free(from_slice_stringified);

        const from_value_stringified = try std.json.stringifyAlloc(allocator, parsed_from_value.value, .{ .whitespace = .indent_2 });
        defer allocator.free(from_value_stringified);

        if (!std.mem.eql(u8, from_slice_stringified, from_value_stringified)) {
            std.debug.print(
                \\
                \\====== std.json.parseFromSlice: ======
                \\{s}
                \\====== std.json.parseFromValue: ======
                \\{s}
                \\======================================\
                \\
            , .{ from_slice_stringified, from_value_stringified });
            return error.TestExpectedEqual;
        }

        try expectEqual(parsed_from_slice.value, parsed_from_value.value);
        try expectEqual(parsed_from_slice.value, expected);
        try expectEqual(parsed_from_value.value, expected);
    }

    fn testParseExpectedError(
        message: []const u8,
        expected_parse_error: std.json.ParseError(std.json.Scanner),
        expected_parse_from_error: std.json.ParseFromValueError,
        parse_options: std.json.ParseOptions,
    ) !void {
        const allocator = std.testing.allocator;

        try std.testing.expectError(expected_parse_error, std.json.parseFromSlice(JsonRPCMessage, allocator, message, parse_options));

        const parsed_value = std.json.parseFromSlice(std.json.Value, allocator, message, parse_options) catch |err| {
            try std.testing.expectEqual(expected_parse_from_error, err);
            return;
        };
        defer parsed_value.deinit();

        try std.testing.expectError(expected_parse_from_error, std.json.parseFromValue(JsonRPCMessage, allocator, parsed_value.value, parse_options));
    }

    fn expectEqual(a: JsonRPCMessage, b: JsonRPCMessage) !void {
        try std.testing.expectEqual(std.meta.activeTag(a), std.meta.activeTag(b));
        switch (a) {
            .request => {
                try std.testing.expectEqualDeep(a.request.id, b.request.id);
                try std.testing.expectEqualStrings(a.request.method, b.request.method);

                // this only a shallow equality check
                try std.testing.expectEqual(a.request.params == null, b.request.params == null);
                if (a.request.params != null) {
                    try std.testing.expectEqual(std.meta.activeTag(a.request.params.?), std.meta.activeTag(b.request.params.?));
                }
            },
            .notification => {
                try std.testing.expectEqualStrings(a.notification.method, b.notification.method);

                // this only a shallow equality check
                try std.testing.expectEqual(a.notification.params == null, b.notification.params == null);
                if (a.notification.params != null) {
                    try std.testing.expectEqual(std.meta.activeTag(a.notification.params.?), std.meta.activeTag(b.notification.params.?));
                }
            },
            .response => {
                try std.testing.expectEqualDeep(a.response.id, b.response.id);
                try std.testing.expectEqualDeep(a.response.@"error", b.response.@"error");

                // this only a shallow equality check
                try std.testing.expectEqual(a.response.result == null, b.response.result == null);
                if (a.response.result != null) {
                    try std.testing.expectEqual(std.meta.activeTag(a.response.result.?), std.meta.activeTag(b.response.result.?));
                }
            },
        }
    }
};

pub fn LSPMessage(
    /// Must be a tagged union with the following properties:
    ///   - the field name is the method name of a request message
    ///   - the field type must be the params type of the method (i.e. `ParamsType(field.name)`)
    /// There may be an optional field named `other` which can have one of the following field types:
    ///   - `[]const u8`
    ///   - `struct{ []const u8 }`
    ///   - `struct{ []const u8, ?std.json.Value }`
    ///   - `struct{ method: []const u8 }`
    ///   - `struct{ method: []const u8, params: ?std.json.Value }`
    /// It will be set with the method name and params if request does not match any of the explicitly specified params.
    ///
    /// Example:
    /// ```zig
    /// union(enum) {
    ///     @"textDocument/implementation": ImplementationParams,
    ///     @"textDocument/completion": CompletionParams,
    ///     /// The request is not one of the above.
    ///     other: struct {
    ///         /// The method to be invoked.
    ///         []const u8,
    ///         /// The requests's params. The `std.json.Value` can only be `.null`, `.array` or `.object`.
    ///         ?std.json.Value,
    ///     },
    /// }
    /// ```
    comptime RequestParams: type,
    /// Must be a tagged union with the following properties:
    ///   - the field name is the method name of a notification message
    ///   - the field type must be the params type of the method (i.e. `ParamsType(field.name)`)
    /// There may be an optional field named `other` which can have one of the following field types:
    ///   - `[]const u8`
    ///   - `struct{ []const u8 }`
    ///   - `struct{ []const u8, ?std.json.Value }`
    ///   - `struct{ method: []const u8 }`
    ///   - `struct{ method: []const u8, params: ?std.json.Value }`
    /// It will be set with the method name and params if notification does not match any of the explicitly specified params.
    ///
    /// Example:
    /// ```zig
    /// union(enum) {
    ///     @"textDocument/didOpen": DidOpenTextDocumentParams,
    ///     @"textDocument/didChange": DidChangeTextDocumentParams,
    ///     other: struct {
    ///         /// The method to be invoked.
    ///         []const u8,
    ///         /// The notification's params. The `std.json.Value` can only be `.null`, `.array` or `.object`.
    ///         ?std.json.Value,
    ///     },
    /// }
    /// ```
    comptime NotificationParams: type,
) type {
    // TODO validate RequestParams and NotificationParams
    return union(enum) {
        request: Request,
        notification: Notification,
        response: JsonRPCMessage.Response,

        const Message = @This();

        pub const Request = struct {
            comptime jsonrpc: []const u8 = "2.0",
            id: JsonRPCMessage.ID,
            params: Params,

            pub const Params = RequestParams;

            pub fn jsonStringify(request: Notification, stream: anytype) @TypeOf(stream.*).Error!void {
                try stream.beginObject();

                try stream.objectField("jsonrpc");
                try stream.write("2.0");

                try stream.objectField("id");
                try stream.write(request.id);

                try jsonStringifyParams(request.params, stream);

                try stream.endObject();
            }
        };

        pub const Notification = struct {
            comptime jsonrpc: []const u8 = "2.0",
            params: Params,

            pub const Params = NotificationParams;

            pub fn jsonStringify(notification: Notification, stream: anytype) @TypeOf(stream.*).Error!void {
                try stream.beginObject();

                try stream.objectField("jsonrpc");
                try stream.write("2.0");

                try jsonStringifyParams(notification.params, stream);

                try stream.endObject();
            }
        };

        pub fn fromMessage(message: JsonRPCMessage, allocator: std.mem.Allocator, options: std.json.ParseOptions) std.json.ParseFromValueError!Message {
            switch (message) {
                inline .request, .notification => |item, tag| {
                    const Params = switch (tag) {
                        .request => RequestParams,
                        .notification => NotificationParams,
                        else => unreachable,
                    };

                    var params: Params = undefined;
                    if (methodToParamsParserMap(Params, std.json.Value).get(item.method)) |parse| {
                        params = try parse(item.params orelse .null, allocator, options);
                    } else if (@hasField(Params, "other")) {
                        params = .{ .other = .{ item.method, item.params } }; // TODO customize
                    } else {
                        return error.UnexpectedToken;
                    }

                    switch (tag) {
                        .request => return .{ .request = .{ .id = item.id, .params = params } },
                        .notification => return .{ .notification = .{ .params = params } },
                        else => unreachable,
                    }
                },
                .response => |response| return .{ .response = response },
            }
        }

        pub fn jsonParse(
            allocator: std.mem.Allocator,
            source: anytype,
            options: std.json.ParseOptions,
        ) std.json.ParseError(@TypeOf(source.*))!Message {
            // TODO this implementation could be made more efficient
            const message = try std.json.innerParse(JsonRPCMessage, allocator, source, options);
            return try fromMessage(message, allocator, options);
        }

        pub fn jsonParseFromValue(
            allocator: std.mem.Allocator,
            source: std.json.Value,
            options: std.json.ParseOptions,
        ) std.json.ParseFromValueError!Message {
            const message = try std.json.innerParseFromValue(JsonRPCMessage, allocator, source, options);
            return try fromMessage(message, allocator, options);
        }

        pub fn jsonStringify(message: Message, stream: anytype) @TypeOf(stream.*).Error!void {
            switch (message) {
                inline else => |item| try stream.write(item),
            }
        }

        /// Identical to `std.json.parseFromSlice(LSPMessage, ...)` but implemented more efficiently.
        pub fn jsonParseFromSlice(
            allocator: std.mem.Allocator,
            s: []const u8,
            options: std.json.ParseOptions,
        ) std.json.ParseError(std.json.Scanner)!std.json.Parsed(Message) {
            var parsed: std.json.Parsed(Message) = .{
                .arena = try allocator.create(std.heap.ArenaAllocator),
                .value = undefined,
            };
            errdefer allocator.destroy(parsed.arena);
            parsed.arena.* = std.heap.ArenaAllocator.init(allocator);
            errdefer parsed.arena.deinit();

            parsed.value = try jsonParseFromSlice(parsed.arena.allocator(), s, options);

            return parsed;
        }

        /// Identical to `std.json.parseFromSliceLeaky(LSPMessage, ...)` but implemented more efficiently.
        pub fn parseFromSliceLeaky(
            allocator: std.mem.Allocator,
            s: []const u8,
            options: std.json.ParseOptions,
        ) std.json.ParseError(std.json.Scanner)!Message {
            std.debug.assert(options.duplicate_field_behavior == .@"error"); // any other behavior is unsupported

            var source = std.json.Scanner.initCompleteInput(allocator, s);
            defer source.deinit();

            if (try source.next() != .object_begin) return error.UnexpectedToken;

            var jsonrpc: ?[]const u8 = null;
            var id: ?JsonRPCMessage.ID = null;
            var state: State = .unknown;

            while (true) {
                const field_name = blk: {
                    const name_token = try source.nextAllocMax(allocator, .alloc_if_needed, options.max_value_len.?);
                    const maybe_field_name = switch (name_token) {
                        inline .string, .allocated_string => |slice| std.meta.stringToEnum(std.meta.FieldEnum(JsonRPCMessage.Fields), slice),
                        .object_end => break, // No more fields.
                        else => return error.UnexpectedToken,
                    };

                    switch (name_token) {
                        .string => {},
                        .allocated_string => |slice| allocator.free(slice),
                        else => unreachable,
                    }

                    break :blk maybe_field_name orelse {
                        if (options.ignore_unknown_fields) {
                            try source.skipValue();
                            continue;
                        } else {
                            return error.UnexpectedToken;
                        }
                    };
                };

                switch (field_name) {
                    .jsonrpc => {
                        if (jsonrpc != null) return error.DuplicateField;
                        jsonrpc = try std.json.innerParseFromValue([]const u8, allocator, source, options);
                        continue;
                    },
                    .id => {
                        if (id != null) return error.DuplicateField;
                        id = try std.json.innerParseFromValue(?JsonRPCMessage.ID, allocator, source, options);
                        continue;
                    },
                    else => {},
                }

                if (state == .method and field_name == .params) {
                    state = try parseParamsWithMethodFromTokenStream(allocator, source, state.method, options);
                    continue;
                } else if (state == .params and field_name == .method) {
                    const method = try std.json.innerParseFromValue([]const u8, allocator, source, options);
                    state = try parseParamsWithMethodFromTokenStream(allocator, state.params, method, options);
                    continue;
                }

                switch (state) {
                    .request, .notification => return error.DuplicateField,
                    .method => switch (field_name) {
                        .jsonrpc, .id => unreachable,
                        .method => return error.DuplicateField,
                        .params => unreachable, // checked above
                        .result, .@"error" => return error.UnexpectedToken,
                    },
                    .params => switch (field_name) {
                        .jsonrpc, .id => unreachable,
                        .method => unreachable, // checked above
                        .params => return error.DuplicateField,
                        .result, .@"error" => return error.UnexpectedToken,
                    },
                    .response_result => |result| switch (field_name) {
                        .jsonrpc, .id => unreachable,
                        .method, .params => return error.UnexpectedToken,
                        .result => return error.DuplicateField,
                        .@"error" => {
                            if (result != .null) return error.UnexpectedToken;

                            state = .{
                                .response = .{
                                    .@"error" = try std.json.innerParse(JsonRPCMessage.Response.Error, allocator, source, options),
                                },
                            };
                            continue;
                        },
                    },
                    .response_error => switch (field_name) {
                        .jsonrpc, .id => unreachable,
                        .method, .params => return error.UnexpectedToken,
                        .result => return error.UnexpectedToken,
                        .@"error" => return error.DuplicateField,
                    },
                    .unknown => switch (field_name) {
                        .jsonrpc, .id => unreachable,
                        .method => {
                            state = .{ .request_or_notification = .{
                                .method = try std.json.innerParse([]const u8, allocator, source, options),
                            } };
                            continue;
                        },
                        .params => {
                            state = .{ .params = source };
                            try source.skipValue();
                            continue;
                        },
                        .result => {
                            state = .{ .response = .{
                                .result = try std.json.innerParse(std.json.Value, allocator, source, options),
                            } };
                            continue;
                        },
                        .@"error" => {
                            state = .{ .response = .{
                                .@"error" = try std.json.innerParse(JsonRPCMessage.Response.Error, allocator, source, options),
                            } };
                            continue;
                        },
                    },
                }
                @compileError("Where is the fallthrough Lebowski?");
            }

            switch (state) {
                .method,
                .params,
                .response_result,
                .response_error,
                .unknown,
                => return error.MissingField,
                .request,
                .notification,
                => {}, // TODO
            }
        }

        fn parseParamsWithMethodFromTokenStream(
            allocator: std.mem.Allocator,
            /// Must be either `*std.json.Scanner` or `*std.json.Reader`.
            source: anytype,
            method: []const u8,
            options: std.json.ParseOptions,
        ) std.json.ParseError(std.json.Scanner)!State {
            std.debug.assert(options.duplicate_field_behavior == .@"error"); // any other behavior is unsupported

            if (methodToParamsParserMap(RequestParams, @TypeOf(source)).get(method)) |parse| {
                return .{ .request = try parse(source, allocator, options) };
            } else if (methodToParamsParserMap(NotificationParams, @TypeOf(source)).get(method)) |parse| {
                return .{ .notification = try parse(source, allocator, options) };
            } else {
                return .{
                    .unknown_request_or_notification = @compileError("TODO"),
                };
            }
        }

        fn ParamsParserFunc(
            /// Must be either `RequestParams` or `NotificationParams`.
            comptime Params: type,
            /// Must be either `*std.json.Scanner`, `*std.json.Reader` or `std.json.Value`.
            comptime Source: type,
        ) type {
            std.debug.assert(Params == RequestParams or Params == NotificationParams);
            return *const fn (params_source: Source, allocator: std.mem.Allocator, options: std.json.ParseOptions) (if (Source == std.json.Value) std.json.ParseFromValueError else std.json.ParseError(Source))!Params;
        }

        inline fn methodToParamsParserMap(
            /// Must be either `RequestParams` or `NotificationParams`.
            comptime Params: type,
            /// Must be either `*std.json.Scanner`, `*std.json.Reader` or `std.json.Value`.
            comptime Source: type,
        ) StaticStringMap(ParamsParserFunc(Params, Source)) {
            comptime {
                const fields = std.meta.fields(Params);
                const has_other_field = @hasField(Params, "other");

                var kvs_list: [fields.len - @intFromBool(has_other_field)]struct { []const u8, ParamsParserFunc(Params, Source) } = undefined;

                var i: usize = 0;
                for (fields) |field| {
                    if (std.mem.eql(u8, field.name, "other")) continue;

                    const parse_func = struct {
                        fn parse(params_source: Source, allocator: std.mem.Allocator, options: std.json.ParseOptions) !Params {
                            const params = switch (Source) {
                                std.json.Value => try std.json.parseFromValueLeaky(field.type, allocator, params_source, options),
                                else => try std.json.innerParse(field.type, allocator, params_source, options),
                            };
                            return @unionInit(Params, field.name, params);
                        }
                    }.parse;

                    kvs_list[i] = .{ field.name, parse_func };
                    i += 1;
                }

                return staticStringMapInitComptime(ParamsParserFunc(Params, Source), kvs_list);
            }
        }

        fn jsonStringifyParams(self: anytype, stream: anytype) @TypeOf(stream.*).Error!void {
            std.debug.assert(@TypeOf(self) == RequestParams or @TypeOf(self) == NotificationParams);

            switch (self) {
                inline else => |field_value, field_name| {
                    if (comptime std.mem.eql(u8, field_name, "other")) {
                        // TODO validation, customizability
                        const method_name, const params = field_value;
                        try stream.objectField("method");
                        try stream.objectField(method_name);

                        if (params) |params_val| {
                            try stream.objectField("params");
                            try stream.write(params_val);
                        } else if (stream.options.emit_null_optional_fields) {
                            try stream.objectField("params");
                            try stream.write(null);
                        }
                    } else {
                        try stream.objectField("method");
                        try stream.objectField(field_name);

                        try stream.objectField("params");
                        try stream.write(field_value);
                    }
                },
            }
        }

        const State = union(enum) {
            request: RequestParams,
            notification: NotificationParams,
            unknown_request_or_notification: @compileError("TODO"),
            method: []const u8,
            params: std.json.Scanner,
            response_result: std.json.Value,
            response_error: JsonRPCMessage.Response.Error,
            unknown,
        };
    };
}

test LSPMessage {
    const ImplementationParamss = @field(@This(), "ImplementationParams");
    const CompletionParamss = @field(@This(), "CompletionParams");
    const RequestMethods = union(enum) {
        @"textDocument/implementation": ImplementationParamss,
        @"textDocument/completion": CompletionParamss,
        other: struct { []const u8, ?std.json.Value },
    };
    const NotificationMethods = union(enum) {
        // @"textDocument/didOpen",
        // @"textDocument/didChange",
        other: struct { []const u8, ?std.json.Value },
    };
    const MyLSPMessage = LSPMessage(RequestMethods, NotificationMethods);

    const parsed_value = try std.json.parseFromSlice(
        std.json.Value,
        std.testing.allocator,
        \\{"jsonrpc": "2.0", "id": 1, "method": "textDocument/completion", "params": {"textDocument": {"uri": "foo"}, "position": {"line": 1, "character": 2}}}
    ,
        .{},
    );
    defer parsed_value.deinit();

    const message = try std.json.parseFromValue(MyLSPMessage, std.testing.allocator, parsed_value.value, .{});
    defer message.deinit();
}

pub fn ResultType(comptime method: []const u8) type {
    if (getRequestMetadata(method)) |meta| return meta.Result;
    if (isNotificationMethod(method)) return void;
    @compileError("unknown method '" ++ method ++ "'");
}

test ResultType {
    comptime {
        std.debug.assert(ResultType("textDocument/hover") == ?lsp_types.Hover);
        std.debug.assert(ResultType("textDocument/inlayHint") == ?[]const lsp_types.InlayHint);
    }
}

pub fn ParamsType(comptime method: []const u8) type {
    if (getRequestMetadata(method)) |meta| return meta.Params orelse void;
    if (getNotificationMetadata(method)) |meta| return meta.Params orelse void;
    @compileError("unknown method '" ++ method ++ "'");
}

test ParamsType {
    comptime {
        std.debug.assert(ParamsType("textDocument/hover") == lsp_types.HoverParams);
        std.debug.assert(ParamsType("textDocument/inlayHint") == lsp_types.InlayHintParams);
    }
}

pub fn getRequestMetadata(comptime method: []const u8) ?RequestMetadata {
    for (request_metadata) |meta| {
        if (std.mem.eql(u8, method, meta.method)) {
            return meta;
        }
    }
    return null;
}

pub fn getNotificationMetadata(comptime method: []const u8) ?NotificationMetadata {
    for (notification_metadata) |meta| {
        if (std.mem.eql(u8, method, meta.method)) {
            return meta;
        }
    }
    return null;
}

const request_method_set: StaticStringMap(void) = blk: {
    var kvs_list: [request_metadata.len]struct { []const u8 } = undefined;
    for (request_metadata, &kvs_list) |meta, *kv| {
        kv.* = .{meta.method};
    }
    break :blk staticStringMapInitComptime(void, kvs_list);
};

const notification_method_set: StaticStringMap(void) = blk: {
    var kvs_list: [notification_metadata.len]struct { []const u8 } = undefined;
    for (notification_metadata, &kvs_list) |meta, *kv| {
        kv.* = .{meta.method};
    }
    break :blk staticStringMapInitComptime(void, kvs_list);
};

/// Return whether there is a request with the given method name.
pub fn isRequestMethod(method: []const u8) bool {
    return request_method_set.has(method);
}

test isRequestMethod {
    try std.testing.expect(!isRequestMethod("initialized"));
    try std.testing.expect(!isRequestMethod("textDocument/didOpen"));

    try std.testing.expect(isRequestMethod("initialize"));
    try std.testing.expect(isRequestMethod("textDocument/completion"));

    try std.testing.expect(!isRequestMethod("foo"));
    try std.testing.expect(!isRequestMethod(""));
}

/// Return whether there is a notification with the given method name.
pub fn isNotificationMethod(method: []const u8) bool {
    return notification_method_set.has(method);
}

test isNotificationMethod {
    try std.testing.expect(isNotificationMethod("initialized"));
    try std.testing.expect(isNotificationMethod("textDocument/didOpen"));

    try std.testing.expect(!isNotificationMethod("initialize"));
    try std.testing.expect(!isNotificationMethod("textDocument/completion"));

    try std.testing.expect(!isNotificationMethod("foo"));
    try std.testing.expect(!isNotificationMethod(""));
}

/// Indicates in which direction a message is sent in the protocol.
pub const MessageDirection = enum {
    client_to_server,
    server_to_client,
    both,
};

test MessageDirection {
    try std.testing.expectEqual(MessageDirection.server_to_client, getRequestMetadata("workspace/configuration").?.direction);
    try std.testing.expectEqual(MessageDirection.client_to_server, getNotificationMetadata("textDocument/didOpen").?.direction);
    try std.testing.expectEqual(MessageDirection.both, getNotificationMetadata("$/cancelRequest").?.direction);
}

pub const RegistrationMetadata = struct {
    /// A dynamic registration method if it different from the request's method.
    method: ?[]const u8,
    /// registration options if the request supports dynamic registration.
    Options: ?type,
};

/// Represents a LSP notification
pub const NotificationMetadata = struct {
    /// The notification's method name.
    method: []const u8,
    documentation: ?[]const u8,
    /// The direction in which this notification is sent in the protocol.
    direction: MessageDirection,
    /// The parameter type if any.
    Params: ?type,
    registration: RegistrationMetadata,
};

/// Represents a LSP request
pub const RequestMetadata = struct {
    /// The request's method name.
    method: []const u8,
    documentation: ?[]const u8,
    /// The direction in which this request is sent in the protocol.
    direction: MessageDirection,
    /// The parameter type if any.
    Params: ?type,
    /// The result type.
    Result: type,
    /// Partial result type if the request supports partial result reporting.
    PartialResult: ?type,
    /// An optional error data type.
    ErrorData: ?type,
    registration: RegistrationMetadata,
};

pub fn Map(comptime Key: type, comptime Value: type) type {
    if (Key != []const u8) @compileError("TODO support non string Key's");
    return std.json.ArrayHashMap(Value);
}

fn StaticStringMap(comptime T: type) type {
    const static_string_map_renamed_zig_version = std.SemanticVersion.parse("0.13.0-dev.33+8af59d1f9") catch unreachable;
    if (@import("builtin").zig_version.order(static_string_map_renamed_zig_version) == .lt) {
        return type;
    } else {
        return std.StaticStringMap(T);
    }
}

fn staticStringMapInitComptime(comptime T: type, comptime kvs_list: anytype) type {
    const static_string_map_renamed_zig_version = std.SemanticVersion.parse("0.13.0-dev.33+8af59d1f9") catch unreachable;
    if (@import("builtin").zig_version.order(static_string_map_renamed_zig_version) == .lt) {
        @setEvalBranchQuota(kvs_list.len * kvs_list.len);
        return std.ComptimeStringMap(T, kvs_list);
    } else {
        return std.StaticStringMap(T).initComptime(kvs_list);
    }
}

pub fn UnionParser(comptime T: type) type {
    return struct {
        pub fn jsonParse(allocator: std.mem.Allocator, source: anytype, options: std.json.ParseOptions) std.json.ParseError(@TypeOf(source.*))!T {
            const json_value = try std.json.Value.jsonParse(allocator, source, options);
            return try jsonParseFromValue(allocator, json_value, options);
        }

        pub fn jsonParseFromValue(allocator: std.mem.Allocator, source: std.json.Value, options: std.json.ParseOptions) std.json.ParseFromValueError!T {
            inline for (std.meta.fields(T)) |field| {
                if (std.json.parseFromValueLeaky(field.type, allocator, source, options)) |result| {
                    return @unionInit(T, field.name, result);
                } else |_| {}
            }
            return error.UnexpectedToken;
        }

        pub fn jsonStringify(self: T, stream: anytype) @TypeOf(stream.*).Error!void {
            switch (self) {
                inline else => |value| try stream.write(value),
            }
        }
    };
}

pub fn EnumCustomStringValues(comptime T: type, comptime contains_empty_enum: bool) type {
    return struct {
        comptime {
            std.debug.assert(@hasField(T, "custom_value") or @hasField(T, "unknown_value"));
        }
        const special_value_indicator: std.meta.Tag(T) = if (@hasField(T, "custom_value")) T.custom_value else T.unknown_value;
        const special_value_field_name: []const u8 = if (@hasField(T, "custom_value")) "custom_value" else "unknown_value";

        const kvs = build_kvs: {
            const KV = struct { []const u8, T };
            const fields = @typeInfo(T).Union.fields;
            var kvs_array: [fields.len - 1]KV = undefined;
            for (fields[0 .. fields.len - 1], &kvs_array) |field, *kv| {
                if (contains_empty_enum and std.mem.eql(u8, field.name, "empty")) {
                    kv.* = .{ "", T.empty };
                } else {
                    kv.* = .{ field.name, @field(T, field.name) };
                }
            }
            break :build_kvs kvs_array;
        };

        const enum_from_string_map: StaticStringMap(void) = staticStringMapInitComptime(T, kvs);

        pub fn eql(a: T, b: T) bool {
            const tag_a = std.meta.activeTag(a);
            const tag_b = std.meta.activeTag(b);
            if (tag_a != tag_b) return false;

            if (tag_a == special_value_indicator) {
                return std.mem.eql(u8, @field(a, special_value_field_name), @field(b, special_value_field_name));
            } else {
                return true;
            }
        }

        pub fn jsonParse(allocator: std.mem.Allocator, source: anytype, options: std.json.ParseOptions) std.json.ParseError(@TypeOf(source.*))!T {
            const slice = try std.json.innerParse([]const u8, allocator, source, options);
            return enum_from_string_map.get(slice) orelse return @unionInit(T, special_value_field_name, slice);
        }

        pub fn jsonParseFromValue(allocator: std.mem.Allocator, source: std.json.Value, options: std.json.ParseOptions) std.json.ParseFromValueError!T {
            const slice = try std.json.parseFromValueLeaky([]const u8, allocator, source, options);
            return enum_from_string_map.get(slice) orelse return @unionInit(T, special_value_field_name, slice);
        }

        pub fn jsonStringify(self: T, stream: anytype) @TypeOf(stream.*).Error!void {
            if (contains_empty_enum and self == .empty) {
                try stream.write("");
                return;
            }
            switch (self) {
                special_value_indicator => |str| try stream.write(str),
                else => |val| try stream.write(@tagName(val)),
            }
        }
    };
}

test EnumCustomStringValues {
    var arena_allocator = std.heap.ArenaAllocator.init(std.testing.allocator);
    defer arena_allocator.deinit();
    const arena = arena_allocator.allocator();

    {
        const E = union(enum) {
            foo,
            bar,
            baz,
            custom_value: []const u8,
            pub const jsonParse = EnumCustomStringValues(@This(), false).jsonParse;
            pub const jsonStringify = EnumCustomStringValues(@This(), false).jsonStringify;
        };

        try std.testing.expectFmt("\"foo\"", "{}", .{std.json.fmt(E{ .foo = {} }, .{})});
        try std.testing.expectFmt("\"bar\"", "{}", .{std.json.fmt(E{ .bar = {} }, .{})});
        try std.testing.expectFmt("\"baz\"", "{}", .{std.json.fmt(E{ .baz = {} }, .{})});
        try std.testing.expectFmt("\"\"", "{}", .{std.json.fmt(E{ .custom_value = "" }, .{})});
        try std.testing.expectFmt("\"boo\"", "{}", .{std.json.fmt(E{ .custom_value = "boo" }, .{})});

        try std.testing.expectEqual(E.foo, try std.json.parseFromSliceLeaky(E, arena, "\"foo\"", .{}));
        try std.testing.expectEqual(E.bar, try std.json.parseFromSliceLeaky(E, arena, "\"bar\"", .{}));
        try std.testing.expectEqual(E.baz, try std.json.parseFromSliceLeaky(E, arena, "\"baz\"", .{}));

        {
            const e: E = try std.json.parseFromSliceLeaky(E, arena, "\"boo\"", .{});
            try std.testing.expectEqual(E.custom_value, std.meta.activeTag(e));
            try std.testing.expectEqualStrings("boo", e.custom_value);
        }

        {
            const e: E = try std.json.parseFromSliceLeaky(E, arena, "\"\"", .{});
            try std.testing.expectEqual(E.custom_value, std.meta.activeTag(e));
            try std.testing.expectEqualStrings("", e.custom_value);
        }
    }

    {
        const E = union(enum) {
            foo,
            bar,
            baz,
            empty,
            unknown_value: []const u8,
            pub const jsonParse = EnumCustomStringValues(@This(), true).jsonParse;
            pub const jsonStringify = EnumCustomStringValues(@This(), true).jsonStringify;
        };

        try std.testing.expectFmt("\"foo\"", "{}", .{std.json.fmt(E{ .foo = {} }, .{})});
        try std.testing.expectFmt("\"bar\"", "{}", .{std.json.fmt(E{ .bar = {} }, .{})});
        try std.testing.expectFmt("\"baz\"", "{}", .{std.json.fmt(E{ .baz = {} }, .{})});
        try std.testing.expectFmt("\"\"", "{}", .{std.json.fmt(E{ .empty = {} }, .{})});
        try std.testing.expectFmt("\"boo\"", "{}", .{std.json.fmt(E{ .unknown_value = "boo" }, .{})});

        try std.testing.expectEqual(E.foo, try std.json.parseFromSliceLeaky(E, arena, "\"foo\"", .{}));
        try std.testing.expectEqual(E.bar, try std.json.parseFromSliceLeaky(E, arena, "\"bar\"", .{}));
        try std.testing.expectEqual(E.baz, try std.json.parseFromSliceLeaky(E, arena, "\"baz\"", .{}));
        try std.testing.expectEqual(E.empty, try std.json.parseFromSliceLeaky(E, arena, "\"\"", .{}));

        {
            const e: E = try std.json.parseFromSliceLeaky(E, arena, "\"boo\"", .{});
            try std.testing.expectEqual(E.unknown_value, std.meta.activeTag(e));
            try std.testing.expectEqualStrings("boo", e.unknown_value);
        }
    }

    {
        const E = union(enum) {
            foo,
            empty,
            custom_value: []const u8,
            pub const jsonParse = EnumCustomStringValues(@This(), false).jsonParse;
            pub const jsonStringify = EnumCustomStringValues(@This(), false).jsonStringify;
        };

        try std.testing.expectFmt("\"foo\"", "{}", .{std.json.fmt(E{ .foo = {} }, .{})});
        try std.testing.expectFmt("\"empty\"", "{}", .{std.json.fmt(E{ .empty = {} }, .{})});
        try std.testing.expectFmt("\"boo\"", "{}", .{std.json.fmt(E{ .custom_value = "boo" }, .{})});

        try std.testing.expectEqual(E.foo, try std.json.parseFromSliceLeaky(E, arena, "\"foo\"", .{}));
        try std.testing.expectEqual(E.empty, try std.json.parseFromSliceLeaky(E, arena, "\"empty\"", .{}));

        {
            const e: E = try std.json.parseFromSliceLeaky(E, arena, "\"boo\"", .{});
            try std.testing.expectEqual(E.custom_value, std.meta.activeTag(e));
            try std.testing.expectEqualStrings("boo", e.custom_value);
        }
    }
}

pub fn EnumStringifyAsInt(comptime T: type) type {
    return struct {
        pub fn jsonStringify(self: T, stream: anytype) @TypeOf(stream.*).Error!void {
            try stream.write(@intFromEnum(self));
        }
    };
}

test EnumStringifyAsInt {
    {
        const E = enum {
            foo,
            bar,
            baz,
            pub const jsonStringify = EnumStringifyAsInt(@This()).jsonStringify;
        };
        try std.testing.expectFmt("0", "{}", .{std.json.fmt(E.foo, .{})});
        try std.testing.expectFmt("1", "{}", .{std.json.fmt(E.bar, .{})});
        try std.testing.expectFmt("2", "{}", .{std.json.fmt(E.baz, .{})});
    }

    {
        const E = enum(u8) {
            foo = 2,
            bar,
            baz = 5,
            pub const jsonStringify = EnumStringifyAsInt(@This()).jsonStringify;
        };
        try std.testing.expectFmt("2", "{}", .{std.json.fmt(E.foo, .{})});
        try std.testing.expectFmt("3", "{}", .{std.json.fmt(E.bar, .{})});
        try std.testing.expectFmt("5", "{}", .{std.json.fmt(E.baz, .{})});
    }

    {
        const E = enum(u8) {
            foo,
            bar = 3,
            baz,
            _,
            pub const jsonStringify = EnumStringifyAsInt(@This()).jsonStringify;
        };
        try std.testing.expectFmt("0", "{}", .{std.json.fmt(E.foo, .{})});
        try std.testing.expectFmt("3", "{}", .{std.json.fmt(E.bar, .{})});
        try std.testing.expectFmt("4", "{}", .{std.json.fmt(E.baz, .{})});
        try std.testing.expectFmt("7", "{}", .{std.json.fmt(@as(E, @enumFromInt(7)), .{})});
    }
}

pub const notification_metadata: [@field(@This(), "notification_metadata_generated").len]NotificationMetadata = @field(@This(), "notification_metadata_generated");
pub const request_metadata: [@field(@This(), "request_metadata_generated").len]RequestMetadata = @field(@This(), "request_metadata_generated");

const lsp_types = @This();

fn testType(comptime T: type) void {
    if (T == void) return;
    if (T == ?void) return;

    const S = struct {
        fn parseFromValue() void {
            _ = std.json.parseFromValue(T, undefined, undefined, undefined) catch unreachable;
        }
        fn innerParse() void {
            var source: std.json.Scanner = undefined;
            _ = std.json.innerParse(T, undefined, &source, undefined) catch unreachable;
        }
        fn stringify() void {
            const value: T = undefined;
            _ = std.json.stringify(value, undefined, std.io.null_writer) catch unreachable;
        }
    };
    _ = &S.parseFromValue;
    _ = &S.innerParse;
    _ = &S.stringify;
}

comptime {
    @setEvalBranchQuota(10_000);

    for (lsp_types.notification_metadata) |metadata| {
        if (metadata.Params) |Params| {
            testType(Params);
        }
    }
    for (lsp_types.request_metadata) |metadata| {
        if (metadata.Params) |Params| {
            testType(Params);
        }
        testType(metadata.Result);
        if (metadata.PartialResult) |PartialResult| {
            testType(PartialResult);
        }
        if (metadata.ErrorData) |ErrorData| {
            testType(ErrorData);
        }
    }

    std.testing.refAllDeclsRecursive(@This());
}
